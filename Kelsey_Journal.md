### Kelsey Werner's Journal

###

#### Feb 16, 2023

Today my project partner, Tito, and I paired on the initial repo set up.  Tito was driving, so all of the commits are in his name.  We started by copying the doggr repo.  Then we went through the files in the top level directory as well as all of the configuration files in the backend directory and updated all of them to reflect the details of our app, Pet or Pass, rather than doggr.  This was pretty simple and straightforward to do.  Pairing also gave us a chance to do some knowledge sharing about Linux commands and web project configurations.

#### Feb 17, 2023

I am owning the database portion of the project, and today I updated all of the database-related code we copied from doggr except for actually executing the migration and the files related to seeding.  We only plan on having one table and are using the same technologies we used in class (Postgresql and TypeORM), so it was pretty simple to make these updates so far.  However, because I haven’t performed the initial migration, I haven’t tested anything yet, and since testing is usually where things get spicy, we’ll see how things actually go when I finish up the work on creating the database portion of the project.

#### Feb 18, 2023

Tito and I decided that we would make static HTML files in order to implement all of our styling because this was something we could work on at the same time as the backend without stepping on each other’s work.  In my opinion, the time consuming work of the frontend won’t be refactoring the HTML into React components, it will be creating all of the CSS styling.  So we decided that it was better to get an early start on the UI and make any changes after implementing the doggr frontend in class rather than putting it off.  Neither of us are really “design people”, so beyond just using the Bootstrap library, we’re also leaning into using the fully fleshed out example components on the Bootstrap website as much as possible.  Today, I collaborated with Tito on some shared design decisions, like the general layout, needed pages, and picking a primary color (we’re going with Pantone’s color of the year: [Viva Magenta](https://www.pantone.com/articles/color-of-the-year/what-is-viva-magenta)).  Then, because I am owning the navigation bar UI, I used an example [Bootstrap component](https://getbootstrap.com/docs/4.0/examples/navbar-fixed/) to create the navigation bar HTML and CSS, and I also used a Bootstrap navigation bar that I created on a previous project as a reference.  Using these resources took a lot of the difficulty out of the nav bar implementation.  We decided that we would create branches on GitHub for our individual work, so that we could create, review, and merge PRs to more closely emulate a “real world” development process.  We are not squashing our commits, so that the individual commits are still visible for grading.  I [made a PR](https://github.com/TotallyNotTito/PetOrPass/pull/2) for the nav bar and merged it into the main branch.

#### Feb 19, 2023

Today I ran the database migration and seeder, and everything went pretty smoothly with only a little bit of debugging needed.  After that I [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/3) and merged it after Tito approved it.  Next I started on the backend routing, and quickly realized that the biggest difference between Pet or Pass and the current state of doggr is that Pet or Pass has to deal with accepting and displaying images from the user.  I made some educated guesses as to what this might look like once MinIO and the frontend are implemented.  This included learning about multipart HTTP messages for receiving the user-submitted image from the frontend and using the Fastify multipart plugin as a possible option to receive the image on the backend.  I decided only to do light testing of some of the routes where I’ve made some design assumptions because I don’t want to sink too much time into perfecting an implementation that might change later.

#### Feb 21, 2023

I realized the findonebyorfail method from TypeORM was just taking the top pet in the pets table (aka selecting the same pet every time the method is called), not randomly selecting a pet from the table like I originally thought it would.  So eventually I had to use query builder as a solution for randomly selecting a pet using [a blog post](https://www.kindacode.com/snippet/typeorm-how-to-select-random-rows/) I found.

#### Feb 26, 2023

I finished implementing backend routing (minus the login/logout and POST routes that have temporary placeholders), so I moved on to implementing the route testing.  I left placeholder tests for the placeholder routes that I haven’t yet finished implementing.  I found the [Vitest documentation](https://vitest.dev/api/expect.html#tocontain) to be extremely helpful for testing items that fell outside of the examples given in doggr.  After finishing up the tests, I [submitted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/4) with the backend routes and integration tests.

#### Feb 27, 2023

Today I created the static HTML and CSS for error pages.  The plan is to use the same 404 error page for when the user tries to access their gallery but hasn't submitted any pets as well as when a user tries to rate pets, but no one has submitted any pets for rating.  However, I will change the text on the error page to match the specific situation.  I used [unDraw](https://undraw.co/illustrations) to find a free SVG to use on the error page that could easily be customized to the primary color of the website.  I also tried to include as many accessibility best practices as possible in all of the HTML pages I’m making for this app like semantic HTML tags, alternate text for images, contrasting text and background colors, and ARIA attributes.  But my accessibility chops are pretty rusty, so I’ve been using the final project I used for the Into to Web Development class as a reference to help me jog my memory.  Even if I don’t do a perfectly accessible implementation, I figured it was better to try to include some level of accessibility rather than none at all.

#### March 5, 2023

I [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/5) for the static error page HTML and CSS.  I forgot how nice it is that Bootstrap makes it really easy to make responsive web pages, so even though responsiveness wasn’t a project requirement, I think it gives the UI a bit more polish and makes the website appear more modern.  Next I started using Bootstrap to work on the static HTML and CSS for the form a user would use to submit a pet image for rating.

#### March 7, 2023

I put the finishing touches on the form for submitting a pet image and [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/6) .  As with the other static UI pages, the goal was just to get the styles looking good, but I will worry about implementing the functionality later when I refactor the form into React.  Because of this, I didn’t test the form or try to connect it to the backend.  In particular in the case of the form, I’m curious to see how React handles multipart content types to see if it will work with the way I set up the backend route that is meant to receive the form data (including the pet image).  I found a helpful [Stack Overflow article](https://stackoverflow.com/questions/3828554/how-to-allow-input-type-file-to-accept-only-image-files) to help me set up the file form field to only accept image types of files.  After finishing up the form UI, I moved on to the gallery view for displaying all of the pets that were submitted by the logged in user as well as the average ratings of each of these pets.  I used [Bootstrap’s card components](https://getbootstrap.com/docs/5.3/components/card/) to display the details for each pet, then I had to spend a bit more time than I would have liked digging through Bootstrap’s documentation to figure out how to get the alignment and spacing of all of the cards to look good.  But ultimately, I was both pleased with the final result as well as reminded of why UI/design work is my least favorite part of web development.  Once I finished this page off, I [submitted another PR](https://github.com/TotallyNotTito/PetOrPass/pull/7).

#### March 8, 2023

I went through all of the code I’ve created so far to clean up TypeScript and linter warnings.  Then I tried to use the new fastify-cors middleware that was presented in class, but ended up receiving error messages that were really difficult to untangle.  After time boxing my work on it, I decided I needed to move on to other parts of the project, and at least for now, stick with the original cors middleware.  However, I may need to revisit updating to fastify-cors if I run into issues in the future.  Additionally, I changed the Pet model, seeding, and testing to make clear that the submitted_by column in the pets table expects user email addresses specifically and not any kind of alphanumeric user ID.  I’m glad that I chose a generic name for the column (submitted_by) rather than something more specific/limiting like user_id or user_email, so making changes for the expected format of the column was easy.  It also meant that I didn’t have to create a database migration to enforce the change.  I [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/8) for this clean up work.

#### March 9, 2023

Next I did the initial set up of the frontend by copying over the config and a few bits of basic functionality from doggr then customizing it for Pet or Pass.  I made stubs for all of the components and set up the React Router routes and links and was able to use the component stubs to test that the frontend routing all worked as expected.  I left out all of the auth work because Tito has been investigating Auth0, and we’re going to meet this weekend to collaborate on adding authentication to both the frontend and backend of our site.  I definitely plan on using the frontend auth set up from doggr, so there will need to be a large refactor of my initial work on the frontend.  I [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/9) for this frontend skeleton.

#### March 10, 2023

I created the static HTML and CSS for the page for rating pet images as “pet” or “pass”.  I needed to make two versions of this page: one for before the pet was rated and one for after.  When this static page is refactored into react, the different buttons that appear for the two different versions of the page will need to get pulled out into their own smaller components that can be switched out from the parent page component.  I [made a PR](https://github.com/TotallyNotTito/PetOrPass/pull/10) for this final static UI page.  After this, I embarked on refactoring the first of our static HTML pages into React: the navigation bar.  The whole process actually went incredibly smoothly by using doggr’s nav bar as a template for separating the concerns of styling versus logic into different smaller components.  It was fun to finally get my hands dirty with some React work!  I [posted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/11) for the nav bar refactor into React.

#### March 11, 2023

Today Tito and I got together to discuss the different parts of the app that we’ve been working on separately, and it was a huge knowledge sharing day.  We walked each other through all of the PRs and branches we’ve made in the last few weeks, and we both got a lot out of learning about each other’s work.  After that we paired on all of the MinIO work that Tito has been doing to create our file storage microservice and made detailed plans on how that should be implemented by using a Python Flask app to serve our microservice in a Docker container.  Then we’ll hit our Flask app’s routes in order to store and retrieve pet images.

Next we paired on refactoring the static HTML for the form for submitting a pet’s name and image into React.  We ran into issues with clearing the image input field after submitting the form.  We ultimately ended up putting it aside temporarily to move on to other parts of the project.  I took a second look later in the day on my own, and eventually ended up figuring out that the useRefs React hook could be used to clear the image field after the image is successfully submitted.  In the process of this, I noticed that the CSS that I stored in frontend/public/index.css was not appearing in components nested deeper than the nav bar, so we moved all of our CSS into frontend/src/App.css and included that file directly in our main.tsx file to resolve the issue.

We finished our pairing for the day by discussing the research into Auth0 that Tito had completed so far, and then finalizing our implementation plans at a high level.  I really wanted to get my hands dirty with implementing some auth work, so I offered to pick up where he left off when we split apart to do our own work for the day.  The auth work for this project ended up being incredibly challenging, in part because I think I started it with a deep level of confusion about how I should approach including Auth0 when comparing it against the work we did in class.  I thought going into it I had a decent understanding of auth, but I ended up spending hours pouring over Auth0 documentation and having a lot of false starts with implementations.  I ultimately had to put it away for the day without feeling like I made much progress despite putting in a lot of effort.

Apart from this, I encountered a few tricky TypeScript warnings today, so I learned a bit more about typing.  I haven’t been able to be perfect about proactively providing types to everything like I would be if this was a “real life” production app, but at minimum, I’ve been trying really hard to address every TypeScript warning as I’ve encountered them so far.

#### March 12, 2023

Tito and I got together again today to compare notes on what we worked on the day before after we split up.  He did a lot of great work with getting MinIo set up, and I explained the “progress” that I’d made on setting up auth.  After that we moved on to pairing again on the form for submitting a pet name and image.  The main piece of the remaining work included figuring out how to use Axios to make a multipart request on the frontend to a route on our backend, and this ended up being much trickier than I thought it would be.  We spent the bulk of our time pairing today figuring out how to make this work by reviewing React documentation, Stack Overflow examples, and testing out different experiments.  Eventually we figured out a method that worked and could finish putting the final touches on the form: sharing a success message to the user after submission, sharing a generic error message with the user if any issues come from the server (including preventing the submission from being saved in the database if the user submits a non-image file), and disabling the submit button if either the pet name or pet image fields are empty. 

After we finished pairing for the day, I picked back up my auth work.  I had a revelation about my approach and realized that a lot of the work that I was trying to do on the backend actually belonged on the frontend which completely changed how I was looking at everything.  From there I realized that I could use the [Auth0 React SDK](https://auth0.com/docs/quickstart/spa/react/interactive#install-the-auth0-react-sdk) and follow its quick set-up guide, and this basically changed my whole world.  I was able to get sign up, login, and password reset working on the frontend.  There’s still a lot of refactoring to be done on the frontend to make a move fully fleshed-out auth context like doggr has, and I need to implement protecting backend routes. However, I ended the day with a working proof of concept on the frontend!

#### March 13, 2023

I picked back up working on authentication today by refactoring our static login page HTML and CSS into React.  Tito made the static version of this page, so I tried to keep as much of his work as possible.  However, I did have to refactor it a bit because instead of having username and password input fields on the form like we thought originally, we instead just needed a button to trigger the Auth0 login page.  I also changed logout to be a link in the nav bar rather than a visible component.  To do this, I used doggr to get the shape of my strategy, but instead used methods from Auth0 for some of the details of the implementation.  Using a similar approach of mixing doggr and Auth0, I refectory the nav bar component to only appear when the user is logged in, and I created a protected routes component that takes the user to the login page if they are unauthenticated and to the Rate Pets page in they are authenticated.

Next I moved on implementing that valid JWTs were being passed to the backend by first adding the [fastify-auth0-verify](https://github.com/nearform/fastify-auth0-verify) package.  This package already had a decorator built into it that I could put on our routes, so I didn’t even have to implement an auth plugin, unlike in doggr.  I ended up struggling a lot with how to directly access the actual token provided by Auth0 on the fontend.  Up until now, my implementation used Auth0 provided methods to check authentication in the React components, but I didn’t directly access the token.  Figuring out how to access the token ended up being very difficult because it wasn’t clearly pointed out in the documentation.  However, by digging deep through the [Auth0 React package documentation](https://auth0.github.io/auth0-react/classes/LocalStorageCache.html), I eventually figured out a way to store and access the token in local storage.  I created a React context and provider to wrap my app to allow all components to have access to the token and make requests to the protected routes on the backend.

I decided not to emulate doggr’s HttpService for DRYing up all of the work for submitting an authenticated request to the backend.  Although this would ultimately reduce the complexity of my code, it would increase the scope and time commitment of my current work because I can’t just copy the HttpService as is.  While I know it isn’t ideal to copy a block of code on all of my components, I’m making the pragmatic decision to leave replicas of the work to access protected routes rather than DRY it up.  Abstracting this work into an HttpService would be high on my list of future enhancements if I had more time.

#### March 14, 2023

Today I continued my work on auth by making a request to the protected route for retrieving all of the pets submitted by a user.  I tried to figure out ways to gracefully manage all possible failure scenarios, like if a 500 is received because there is an issue with the token, then the user is logged out and redirected to login.  I ended up running into a CORS error, so at this point I tried using the updated version of fastify’s CORS plugin implemented in doggr.  This new version worked perfectly to resolve my CORS issue without needing any adjustments.

#### March 15, 2023

I took the work I did using Axios on the frontend to hit protected routes on the backend to refactor the the Submit Pet components because this component sends a multipart request to the backend.  This went really quickly and smoothly because I’d already worked out the kinks on how to do this, and even though there were a few small bugs I uncovered, they were overall pretty simple to work out.  However, there was one bug that required me to change how we re-named submitted images (we chose to rename images before saving them to the database and MinIO to make sure they have unique names).

This change would also require me to change the backend integration tests I wrote when I originally implemented routing and database access.  These same tests were already needing a refactor because they tested routes that were now protected by authentication.  Because testing is not a requirement, I ultimately decided that there wasn’t time to accommodate these changes and removed the tests from the repo.  For this same reason, I also decided not to include frontend tests.  As someone with a lot of software testing experience, I 100% do not endorse this strategy for a production app, and I feel strongly that testing should always be factored into time estimates for projects.  Because of this, I would consider creating unit and integration tests as the highest priority future enhancement if we had more time to work on our app.

After removing the tests, I was finished with the rest of the auth work and [submitted a PR](https://github.com/TotallyNotTito/PetOrPass/pull/14).  Before we merged the PR, Tito and I did a thorough walk through of all of my changes.  Next I moved onto refactoring the static HTML and CSS for the error page into React, and since this was such a simple component, it went really smoothly.  Then I tried to delete the public directory from the backend because we didn’t have any files that we needed to store in it.  However, I got a warning from the server that the public directory is necessary, so I added it back in with a .keep file to appease the server warning.

#### March 16, 2023

Today I refactored the static HTML and CSS for the pet gallery page, but there will be more work to do on this page to display images once the integration with MinIO is implemented.  After that I moved onto refactoring the static HTML and CSS for the Rate Pets page into React, and while I was able to build off many lessons from refactoring the other frontend components, this was definitely the most complex component so far.  I split the parent component into several different child components because so much of this page is shown conditionally.  This resulted in way too many props being passed down from the parent component to the child components, and in retrospect, the parent component for this page might have been a good candidate for a React context for this reason.  This refactor would be a good future enhancement.  I wrapped up my work for the day by [posting a PR](https://github.com/TotallyNotTito/PetOrPass/pull/15).

#### March 17, 2023

I began working on getting our app up and running in Docker.  I started by going through the [doggr branch](https://github.com/CaseyBaileyPDX/doggr_w23/tree/microsvc_auth) we reviewed in class and went commit by commit to get the backend, the frontend, Postgres, and MinIO running using the docker compose command.  To test this work I deleted all pre-existing Docker containers, networks, and volumes, I dropped the TypeORM schema, and deleted all directories not tracked by GitHub like node_modules, logs, and build just to make sure I was starting with a totally fresh canvas.  I also learned that I could use the docker system prune -a command to make sure to fully clear out everything because even though I thought I deleted all Docker build artifacts manually, there were still files cached.

I ran into a major issue when adding the pnpm migration:run command to the backend Dockerfile. This was because of a race condition between the backend container and the Postgres container where the backend build was trying to access the Postgres container before Postgres was actually up and running inside its container.  I implemented a health check using [an example Casey shared with me](https://github.com/peter-evans/docker-compose-healthcheck), but I just could not get the healthcheck to actually postpone the backend container’s build.  I ended up getting a lot of debugging help from Casey which was great because I’m still pretty new to Docker, so I learned a lot from it.  While we didn’t resolve the race condition issue, we did find and fix another issue being caused by the incorrect environment variables being placed in docker-compose.yaml.

#### March 18, 2023

After a very long battle with the Docker issue mentioned in the previous post, I figured out a way to get the backend build to wait on the Postgres container.  I found a [Stack Overflow article](https://stackoverflow.com/questions/31746182/docker-compose-wait-for-container-x-before-starting-y) that suggested putting a bash command directly into the backend Dockerfile that explicitly waited until we can connect with the Postgres container before attempting to run the migration.  This was the final touch on getting everything up and running using Docker, and I [made a PR](https://github.com/TotallyNotTito/PetOrPass/pull/16) with all of this work.

I wanted experience with building a microservice, so I picked up the work Tito started with setting up our Flask microservice to build routes to expose access to the MinIO container to the backend and frontend of the application.  I started with making sure the Flask app worked locally before running it using Docker.  I created a Flask route to accept multipart requests and store the image in the request to MinIO.  This included updating the Fastify backend POST route that sends the image to the Flask route to be able to send a multipart request with the pet image that was originally submitted by the user on the frontend then sent to the Fastify backend route.  Despite learning more about multipart requests when sending an image from the frontend to the Fastify backend when working on the React form component, getting another multipart request to successfully forward the image from the backend to the Flask microservice was extremely difficult.  I tried many solutions, but every time the image that arrived at the Flask microservice was corrupted.  Eventually I figured out a successful work around: upon receiving the image on the backend, I stored it temporarily locally in the backend.  Then I sent the multipart request with this local version of the image as a stream to the Flask route, and after it was received by the microservice, I deleted the temporary copy in the Fastify backend.  Next I updated the instantiation of our MinIO Python client to use the MinIO Docker container rather than the sandbox test environment credentials listed in the MinIO documentation.  This allowed me to finish up by storing the image received by the Flask microservice into the MinIO instance running in Docker.  The trickiest piece of this final bit was figuring out the file size required by the MinIO Python library, but I found a [Stack Overflow article](https://stackoverflow.com/questions/15772975/flask-get-the-size-of-request-files-object/23601025#23601025) that helped me to get that information off of the image object when it was received by Flask.

#### March 19, 2023

Today I continued with the microservice implementation by setting up a Flask route to receive a request from the frontend client for an image, retrieve that image from MinIO, and then serve that image to the frontend so that it can be displayed in the UI.  This went significantly smoother than storing the image, and I didn’t encounter any issues.

The last piece of functionality needed was creating a Dockerfile for the Flask microservice then including it in the docker-compose.yaml.  I made the Dockerfile as simple as possible to make sure that I was able to create a working container without any additional complexity interfering.  I chose an Alpine Python image to start with because of its small size and the fact that it already had a bunch of Python-related tools like pip installed.  When I took CS-530 last quarter, I made a few Dockerfiles for Python applications, so I was able to use these Dockerfiles as a helpful reference.  When I tried to test out building and spinning up all of the Dockerfiles together (including the one for the Flask microservice) using the docker compose up command, I ran into an unexpected issue with the backend’s Dockerfile.  For some reason, the bash script that I added directly to the backend’s Dockerfile could no longer connect with the Postgres container, and the backend container’s build was left spinning in an endless loop trying to connect to Postgres.  I even tried checking out the main branch which previously had a working version of this backend Dockerfile, and I still encountered the same issue.  It was definitely one of the stranger bugs I encountered while working on this project, but luckily, I was able to revisit the [Stack Overflow article](https://stackoverflow.com/questions/31746182/docker-compose-wait-for-container-x-before-starting-y) that gave me the original solution.  I used it to find a re-worked version of the solution where instead of using a bash script directly in the Dockerfile, I put it in its own .sh file that I called from within the Dockerfile.  I don’t fully understand why this version of the solution has worked consistently, while my original version broke, but I’m just happy to have all of my Dockerfiles working and working docker-compose.yaml.  At this point, the MinIO and Flask microservice work was complete, and Tito made a PR since my work was based on the foundation he created.

All that was left to do on the site was a bit of linting and TypeScript clean up work.  I really struggled with addressing the TypeScript warnings I found in the React components, and ultimately decided that I did the best I could with the time and knowledge that I have.  In the future, I would really like to expand my understanding of TypeScript because I see it as a really valuable tool, and it would be a cool experience to then revisit this project and see if I could more successfully address the TypeScript warnings with more knowledge and experience.  So although I wish I could have done more in this area, I [submitted my PR](https://github.com/TotallyNotTito/PetOrPass/pull/18) with my best attempt at cleaning up the site.

#### March 20, 2023

To do a final test of the app, as Casey suggested, I made a completely fresh instance of a Ubuntu virtual machine.  I used the commands in Canvas from the set up process at the very beginning of the quarter to add Docker to this machine (but I skipped the steps to add Node.js and pnpm).  Then I set up ssh with my GitHub account so that I could clone the repo.  Using this fresh machine, I was able to thoroughly and successfully test the application without experiencing any bugs.  So then I was able to move onto creating a README with some helpful instructions and info about the app.  I [made a PR](https://github.com/TotallyNotTito/PetOrPass/pull/19), and now our Pet or Pass web application is officially done!

